<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="时间不负有心人">
<meta name="keywords" content="前端,web开发,php,vue,node,广交朋友,欢迎交流!">
<meta property="og:type" content="website">
<meta property="og:title" content="王相的个人博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="王相的个人博客">
<meta property="og:description" content="时间不负有心人">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王相的个人博客">
<meta name="twitter:description" content="时间不负有心人">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>王相的个人博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">王相的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">时间不负有心人</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/React/react_day01/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/React/react_day01/" itemprop="url">React简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-18T14:50:04+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h3><ul>
<li><p>libary（库）：小而精，只提供特定的API，只专精于某一项功能，如vuex（数据管理库）jquery（专注于操作DOM）axios（专注于数据的请求）</p>
</li>
<li><p>Framework（框架）：大而全，面面俱到的，在使用过程中，提供了用户所需要的完整的解决方案，如三大框架vue，react，angular</p>
</li>
<li><p>组件化：基于UI界面对代码进行封装重用</p>
</li>
<li><p>模块化：基于业务逻辑对代码进行封装重用</p>
</li>
</ul>
<h3 id="React概念"><a href="#React概念" class="headerlink" title="React概念"></a>React概念</h3><ul>
<li><p>DOM：浏览器为了表现页面结构，使用js对象对元素标签进行封装，并提供了操作DOM对象的API</p>
</li>
<li><p>虚拟DOM：框架里面的概念，框架里面为了表现DOM元素使用js对象来模拟DOM元素和嵌套关系</p>
<p>1.本质：js的对象，模拟页面DOM的嵌套结构</p>
<p>2.目的：实现页面的高校更新</p>
<p>3.实现高效更新的过程：</p>
<ul>
<li>3.1 页面第一次渲染时候，内存中先生成对象A</li>
</ul>
<ul>
<li><p>3.2 当页面发生变化了，再在内存中生成一个新的对象B</p>
</li>
<li><p>3.3 将AB对象进行对比，找出两者有差异的部分，存储在内存中为对象C</p>
</li>
</ul>
</li>
<li><p>3.4. 在页面再次渲染时，只渲染C，就实现了高效更新</p>
</li>
<li><p>对象差异化对比 Diff算法</p>
</li>
</ul>
<h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><ol>
<li><p>TreeDIff:  最顶层的对比，判断两个虚拟DOM树类型是否一样。</p>
<p>如果不一样，就直接渲染新的虚拟Dom<br>如果一样，再去实现ComponentDiff<br>（    这里的组件是指tree里面的属性名）</p>
</li>
</ol>
<ol start="2">
<li><p>ComponentDiff ：如果虚拟Dom类型一样，再对比组件类型是否一样，如果不一样，直接记录当前的组件，接着对比下一个组件；如果一样，再实现ElementDiff</p>
</li>
<li><p>ElementDiff：（这里可以看作是属性值）如果组件类型一样，再对比里面的元素是否一样，如果不一样，就记录下来，最后渲染这个虚拟DOM</p>
<p> // tree属性的对比，相当是TreeDIff<br> // name属性名的对比，相当是ComponentDiff<br> // 属性值的对比，相当是ElementDiff<br> const obj1 = {</p>
<pre><code>tree:&apos;A&apos;,
name:&apos;zs&apos;
}
</code></pre><p> const obj2= {</p>
<pre><code>tree:&apos;B&apos;,
name:&apos;ls&apos;
}
</code></pre></li>
</ol>
<h2 id="webpack4"><a href="#webpack4" class="headerlink" title="webpack4"></a>webpack4</h2><p>配置文件webpack.config.js中使用module.exports 暴露文件</p>
<pre><code>module.exports = {
   mode:&quot;development&quot;
}
</code></pre><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><blockquote>
</blockquote>
<h4 id="html-webpack-plugin插件"><a href="#html-webpack-plugin插件" class="headerlink" title="html-webpack-plugin插件"></a>html-webpack-plugin插件</h4><ol start="2">
<li><p>安装自动生成内存中的index页面的插件：</p>
<p>  npm i html-webpack-plugin -D</p>
</li>
</ol>
<h2 id="创建基本的webpack4-x项目"><a href="#创建基本的webpack4-x项目" class="headerlink" title="创建基本的webpack4.x项目"></a>创建基本的webpack4.x项目</h2><ol>
<li>运行<code>npm init -y</code> 快速初始化项目</li>
<li>在项目根目录创建<code>src</code>源代码目录和<code>dist</code>产品目录</li>
<li>在 src 目录下创建 <code>index.html</code></li>
<li>使用 cnpm 安装 webpack ，运行<code>cnpm i webpack webpack-cli -D</code><ul>
<li>如何安装 <code>cnpm</code>: 全局运行 <code>npm i cnpm -g</code></li>
</ul>
</li>
<li>注意：webpack 4.x 提供了 约定大于配置的概念；目的是为了尽量减少 配置文件的体积；<ul>
<li>默认约定了：</li>
<li>打包的入口是<code>src</code> -&gt; <code>index.js</code></li>
<li>打包的输出文件是<code>dist</code> -&gt; <code>main.js</code></li>
<li>4.x 中 新增了 <code>mode</code> 选项(为必选项)，可选的值为：<code>development</code> 和 <code>production</code>;</li>
</ul>
</li>
</ol>
<h3 id="html-webpack-plugin插件-自动去导入内存中的index页面"><a href="#html-webpack-plugin插件-自动去导入内存中的index页面" class="headerlink" title="html-webpack-plugin插件 自动去导入内存中的index页面"></a>html-webpack-plugin插件 自动去导入内存中的index页面</h3><pre><code>    const path = require(&apos;path&apos;)

    const HtmlWebPackPlugin = require(&apos;html-webpack-plugin&apos;) // 导入 在内存中自动生成 index 页面的插件

// 创建一个插件的实例对象

    const htmlPlugin = new HtmlWebPackPlugin({
      template: path.join(__dirname, &apos;./src/index.html&apos;), // 源文件
      filename: &apos;index.html&apos; // 生成的内存中首页的名称
    })
</code></pre><h4 id="使用React"><a href="#使用React" class="headerlink" title="使用React"></a>使用React</h4><ol>
<li><p>安装包 </p>
<pre><code>cnpm i react react-dom -S 安装包
</code></pre></li>
</ol>
<ol start="2">
<li><p>导入：必须大写</p>
<pre><code>import React from &apos;react&apos;
import ReactDOM from &apos;react-dom&apos; 
</code></pre></li>
<li><p>使用react提供的API创建虚拟DOM元素：</p>
<p>  const myh1 = React.createElement(‘h1’, { title: ‘啊，五环’, id: ‘myh1’ }, ‘你比四环多一环’)</p>
</li>
<li><p>使用react提供的API渲染虚拟DOM元素：</p>
<pre><code>ReactDOM.render(&lt;Hello username={obj.name} age={obj.age} /&gt;,document.getElementById(&apos;app&apos;))
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/React/react_tea/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/React/react_tea/" itemprop="url">React资料整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-18T14:50:04+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>[TOC]</p>
<h3 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h3><blockquote>
<p><strong>库</strong>:<strong>小而精</strong>,从功能上来说的话,就是专精某一项功能(jquery,axios)</p>
<p><strong>框架</strong>:<strong>大而全</strong>,从功能上来说就是面面俱到,在使用框架的过程中提供了用户所需要的完整的解决方案。(vue,bootstrap)</p>
<p><strong>组件化</strong>: 基于<strong>UI界面</strong>对代码进行封装重用</p>
<p><strong>模块化</strong>: 基于<strong>业务逻辑</strong>对代码进行封装重用</p>
</blockquote>
<h3 id="React概念"><a href="#React概念" class="headerlink" title="React概念"></a>React概念</h3><h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><blockquote>
<p>DOM：浏览器中为了表现页面结构使用JS对象对元素进行模拟。</p>
<p>虚拟DOM: 框架中为了表示DOM元素使用JS对象对DOM进行模拟。</p>
<p><strong>虚拟DOM的本质</strong>: 就是JS的对象,用于模拟页面DOM的嵌套关系。</p>
<p><strong>虚拟DOM的目的</strong>: 实现页面的高效更新。</p>
<p><strong>虚拟DOM实现高效更新的过程</strong>:</p>
<ol>
<li>页面在第一次渲染时,内存中存在对象A(虚拟DOM)</li>
<li>当页面发生变化时,在内存中生成一个新的对象B(虚拟DOM)</li>
<li>对对象A和对象B进行对比,找出有差异的地方，存储到内存中C(虚拟DOM)</li>
<li>在页面进行渲染时,只渲染C即可实现高效更新。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// tree属性的对比 相当于TreeDIff</span><br><span class="line">// 属性名称的对比,相当于ComponentDiff</span><br><span class="line">// 属性值的对比, 相当于ElementDiff</span><br><span class="line">const obj1 = &#123;</span><br><span class="line">	tree:&apos;A&apos;</span><br><span class="line">	</span><br><span class="line">    name:&apos;zs&apos;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;</span><br><span class="line">	tree:&apos;B&apos;</span><br><span class="line">	</span><br><span class="line">	name:&apos;ls&apos;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><blockquote>
<p><strong>TreeDIff</strong>:最顶层的对比,判断连个虚拟DOM树类型是否一样,如果不一样，则直接渲染新虚拟DOM,如果一样，再实现ComponentDiff</p>
<p><strong>ComponentDiff</strong>:如果虚拟DOM类型一样,再对比组件类型是否一样,如果不一样,直接记录当前组件，接着对比下一个组件；如果一样，再实现ElementDiff</p>
<p><strong>ElementDiff</strong>：如果组件类型一样，再对比组件中的元素是否一样，如果不一样,记录下来,找到所有记录的内容(虚拟DOM)，最后渲染这个虚拟DOM</p>
</blockquote>
<h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><h3 id="webpack4-0"><a href="#webpack4-0" class="headerlink" title="webpack4.0"></a>webpack4.0</h3><h4 id="基本环境配置"><a href="#基本环境配置" class="headerlink" title="基本环境配置"></a>基本环境配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建项目文件夹</span></span><br><span class="line">mkdir webpack-study</span><br><span class="line"><span class="comment">// 2. 使用npm初始化package.json</span></span><br><span class="line">npm init</span><br><span class="line"><span class="comment">// 3. 进入项目文件夹创建对应的子文件夹和文件</span></span><br><span class="line">mkdir src dist</span><br><span class="line">touch webpack.config.js</span><br><span class="line"><span class="comment">// 4. 进入src目录创建index.html/index.js </span></span><br><span class="line">touch index.html index.js</span><br><span class="line"><span class="comment">// 5. 使用npm命令安装webpack webpack-cli</span></span><br><span class="line">cnpm i webpack webpack-cli -D</span><br><span class="line"><span class="comment">// 6. 在webpack配置文件中书写如下内容</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode:<span class="string">"development"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7. 执行webpack命令进行打包(一定要确定是在当前项目根目录下面运行命令)</span></span><br><span class="line">webpack</span><br></pre></td></tr></table></figure>
<h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><blockquote>
<p>是一个小型的Node服务器,用于托管当前项目中所有代码,同时监听文件的变化,自动进行打包编译</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装webpack-dev-server</span></span><br><span class="line">npm i webpack-dev-server -D</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在package.json文件中加入以下代码</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>:<span class="string">"webpack-dev-server --open --hot --port 8888"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 更改index.html中main.js导入的路径</span></span><br><span class="line">&lt;script src=<span class="string">"/main.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 在项目根目录运行命令启动项目</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><blockquote>
<p>根据指定的模板文件生成一个内存中index.html文件存在于项目的根目录。同时可以在生成的这个文件中自动添加打包好的main.js文件。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装html-webpack-plugin</span></span><br><span class="line">npm i html-webpack-plugin -D</span><br><span class="line"><span class="comment">// 2. 在webpack.config.js中加入插件配置</span></span><br><span class="line"><span class="keyword">const</span> path  = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">// 导入html-webpack-plugin</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin  = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">// 创建HtmlWebpackPlugin实例对象</span></span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: path.join(__dirname,<span class="string">'./src/index.html'</span>), <span class="comment">// 模板文件的绝对路径</span></span><br><span class="line">  filename:<span class="string">'index.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3. 在module.exports导出对象中添加如下代码</span></span><br><span class="line">plugins:[</span><br><span class="line">   htmlWebpackPlugin</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 4. 去掉index.html中导入的main.js标签</span></span><br><span class="line"><span class="comment">// 5. 重新执行命令运行项目</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<h3 id="JSX语法-1"><a href="#JSX语法-1" class="headerlink" title="JSX语法"></a>JSX语法</h3><blockquote>
<p>在JS中书写符合XML规范的语法</p>
<p>JSX解析过程:遇到<code>&lt;</code>以<code>HTML</code>规则解析,遇到<code>{}</code>以<code>JS</code>规则解析</p>
</blockquote>
<h4 id="配置babel-loader解析jsx语法"><a href="#配置babel-loader解析jsx语法" class="headerlink" title="配置babel-loader解析jsx语法"></a>配置babel-loader解析jsx语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装相关的包-直接装以下包</span></span><br><span class="line">yarn add babel-loader --dev</span><br><span class="line">yarn add @babel/core --dev</span><br><span class="line">yarn add @babel/plugin-transform-runtime --dev</span><br><span class="line">yarn add @babel/plugin-proposal-<span class="class"><span class="keyword">class</span>-<span class="title">properties</span> --<span class="title">dev</span></span></span><br><span class="line"><span class="class"><span class="title">yarn</span> <span class="title">add</span> @<span class="title">babel</span>/<span class="title">preset</span>-<span class="title">env</span> --<span class="title">dev</span></span></span><br><span class="line"><span class="class"><span class="title">yarn</span> <span class="title">add</span> @<span class="title">babel</span>/<span class="title">runtime</span> --<span class="title">dev</span></span></span><br><span class="line"><span class="class"><span class="title">yarn</span> <span class="title">add</span> @<span class="title">babel</span>/<span class="title">preset</span>-<span class="title">react</span> --<span class="title">dev</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 2. 在根目录下添加.<span class="title">babelrc</span>文件，并书写以下代码</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">    <span class="string">"@babel/plugin-proposal-class-properties"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">     <span class="string">"@babel/react"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在webpack.config.js中配置中书写以下代码</span></span><br><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;<span class="attr">test</span>:<span class="regexp">/\.js|jsx$/</span>,<span class="attr">use</span>:<span class="string">'babel-loader'</span>,<span class="attr">exclude</span>:<span class="regexp">/node_modules/</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="集成react渲染虚拟DOM"><a href="#集成react渲染虚拟DOM" class="headerlink" title="集成react渲染虚拟DOM"></a>集成react渲染虚拟DOM</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装react、react-dom</span></span><br><span class="line"><span class="comment">// yarn add react react-dom / cnpm react react-dom -S</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 导入react、react-dom</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用react提供的API创建虚拟DOM</span></span><br><span class="line"><span class="comment">// const mydiv = React.createElement('div',&#123;className:'box'&#125;,'这是虚拟DOM对象')</span></span><br><span class="line"><span class="keyword">const</span> mydiv = &lt;div className="box"&gt;</span><br><span class="line">  这是虚拟DOM对象</span><br><span class="line">  &#123;list.map((v,i) =&gt; &lt;p key=&#123;i&#125;&gt;&#123;v&#125;&lt;/p&gt;)&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用react-dom提供的API渲染虚拟DOM</span></span><br><span class="line">ReactDOM.render(&lt;Hello username=&#123;obj.name&#125; age=&#123;obj.age&#125; /&gt;,document.getElementById('app'))</span><br></pre></td></tr></table></figure>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h4><blockquote>
<p>无状态组件：通过构造函数方式创建的组件,组件内部没有生命周期函数和私有数据。</p>
<p>无状态组件是一个<strong>纯函数</strong></p>
<p><strong>纯函数</strong>：函数内部对接收到数据不做任何处理,这样的函数称作纯函数</p>
</blockquote>
<ul>
<li>创建方式</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以构造函数方式创建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;构造函数方式创建的组件&lt;<span class="regexp">/h3&gt;	</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以标签的方式使用</span></span><br><span class="line">ReactDOM.render(&lt;Hello /&gt;,document.getElementById('app'))</span><br></pre></td></tr></table></figure>
<ul>
<li>传值</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参props用于接收传递的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h3&gt;构造函数方式创建的组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;&#123;props.name&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;p&gt;&#123;props.age&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'zs'</span>,</span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReactDOM.render(&lt;Hello username=&#123;obj.name&#125; age=&#123;obj.age&#125; /&gt;,document.getElementById('app'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性扩散(使用es6的展开运算符进行传值)</span></span><br><span class="line">ReactDOM.render(&lt;Hello &#123;...obj&#125; /&gt;,document.getElementById('app'))</span><br></pre></td></tr></table></figure>
<h5 id="配置webpack省略文件后缀和项目根目录"><a href="#配置webpack省略文件后缀和项目根目录" class="headerlink" title="配置webpack省略文件后缀和项目根目录"></a>配置webpack省略文件后缀和项目根目录</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在webpack.config.js中添加如下配置</span></span><br><span class="line">resolve:&#123;</span><br><span class="line">    extensions:[<span class="string">'.js'</span>,<span class="string">'.jsx'</span>,<span class="string">'.json'</span>], <span class="comment">// 省略.jsx后缀名</span></span><br><span class="line">    alias:&#123;</span><br><span class="line">      <span class="string">"@"</span>:path.join(__dirname,<span class="string">'./src'</span>) <span class="comment">// 配置src目录的绝对路径为@</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h4><blockquote>
<p>有状态组件：通过class关键字创建的组件,组件内部可以定义生命周期函数和私有数据。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="comment">// 定义私有数据</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">      render()&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">          &lt;h3&gt;这是class关键字创建的组件&lt;/h3&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class-extends关键字"><a href="#class-extends关键字" class="headerlink" title="class/extends关键字"></a>class/extends关键字</h3><blockquote>
<p>实例成员:</p>
<ol>
<li>实例属性：通过实例对象进行访问的属性叫做实例属性</li>
<li>实例方法：通过实例对象调用的方法叫做实例方法</li>
</ol>
<p>静态成员:</p>
<ol>
<li>静态属性：通过构造函数或者类名进行访问的属性叫做静态属性</li>
<li>静态方法：通过构造函数或者类名调用的方法叫做静态方法</li>
</ol>
<p><code>extends</code>实现继承:</p>
<ol>
<li>在子类内部如果书写了<code>constructor,`</code>constructor<code>内部必须调用</code>super`函数</li>
<li>在子类里面如果需要传参,需要在<code>constructor</code>定义形参,在<code>super</code>上传入形参</li>
</ol>
<p>注意:</p>
<ol>
<li><p>调用子类的<code>super</code>其实就是在调用父类的<code>constructor</code></p>
</li>
<li><p><code>super</code>函数内部会创建父类的<code>this</code>，同时会将父类的<code>this</code>指向子类的实例</p>
</li>
</ol>
</blockquote>
<h4 id="构造函数方式创建对象"><a href="#构造函数方式创建对象" class="headerlink" title="构造函数方式创建对象"></a>构造函数方式创建对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态属性(直接挂载到构造函数上面)</span></span><br><span class="line">Person.count = <span class="string">"60亿"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">Person.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    conso.log(<span class="string">'run'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'李白'</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(Person.count)</span><br><span class="line"></span><br><span class="line">---继承---</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chinese</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型继承(让子类的原型指向父类的一个实例)</span></span><br><span class="line">Chinese.prototype = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Chinese()</span><br></pre></td></tr></table></figure>
<h4 id="Class类方式创建对象"><a href="#Class类方式创建对象" class="headerlink" title="Class类方式创建对象"></a>Class类方式创建对象</h4><blockquote>
<p><code>class</code>类的花括号不是一个对象，内部只允许写函数以及使用<code>static</code>关键字定义静态属性或者静态方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态属性(通过static关键字创建静态属性)</span></span><br><span class="line">    <span class="keyword">static</span> count = <span class="string">"60亿"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> run()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'run'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实例方法</span></span><br><span class="line">    say()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'李白'</span>,<span class="number">1000</span>)</span><br><span class="line">p.say()</span><br><span class="line"><span class="built_in">console</span>.log(Person.count)</span><br><span class="line">Person.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Chinese(<span class="string">'韩信'</span>,<span class="number">2000</span>)</span><br><span class="line">c.say()</span><br><span class="line"></span><br><span class="line">Chinese.run()</span><br></pre></td></tr></table></figure>
<h3 id="CSS-IN-JS-样式"><a href="#CSS-IN-JS-样式" class="headerlink" title="CSS-IN-JS 样式"></a>CSS-IN-JS 样式</h3><h4 id="style行内样式"><a href="#style行内样式" class="headerlink" title="style行内样式"></a>style行内样式</h4><blockquote>
<p>注意:</p>
<ol>
<li>行内样式<code>style</code>属性后面跟的是一个js对象,所以需要时<code>{}</code>进行包裹</li>
<li>组件的样式属性都以键值对的方式在样式对象中进行描述</li>
<li>对于带中划线的样式属性,需要改为驼峰命名或者把属性名用引号引起了</li>
</ol>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div style=&#123;&#123;color:'red',backgroundColor:'pink','font-size':'16px'&#125;&#125;&gt;</span><br><span class="line">        绝云气,负青天</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="css文件书写样式"><a href="#css文件书写样式" class="headerlink" title="css文件书写样式"></a>css文件书写样式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装解析css文件的加载器</span></span><br><span class="line">yarn add style-loader css-loader --dev</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在webpack.config.js中添加解析后缀为.css文件的加载器解析规则</span></span><br><span class="line">&#123;</span><br><span class="line">  test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">  use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">  <span class="comment">// css-loader 解析后缀为.css的文件,读取出css文件中的样式代码</span></span><br><span class="line">  <span class="comment">// style-loader 将样式代码插入到html中成为内联样式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 书写css文件,并在组件中导入使用</span></span><br><span class="line"><span class="keyword">import</span> cssobj <span class="keyword">from</span> <span class="string">'./css/index.css'</span></span><br></pre></td></tr></table></figure>
<h5 id="给css文件启用模块化"><a href="#给css文件启用模块化" class="headerlink" title="给css文件启用模块化"></a>给css文件启用模块化</h5><blockquote>
<p>注意:</p>
<ol>
<li><strong>模块化只能作用在类名选择器和id选择器上面,对于标签选择器不生效。</strong></li>
<li><strong>如果id选择器和类名选择器同名,会安装权重使用id选择器的样式</strong></li>
<li>在启用模块化后,css文件中的所有样式默认都是会被模块化处理,可以使用<code>:global(选择器{})</code>这种方式将某些样式成为具有全局作用域的样式。<em><code>:local(选择器{})</code>也可以单独指定某个选择器具有单独作用域</em></li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 在配置解析规则时添加models参数启用模块化</span></span><br><span class="line">&#123;</span><br><span class="line">  test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">  use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader?modules'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 在导入css文件时用对象进行接收</span></span><br><span class="line"><span class="keyword">import</span> cssobj <span class="keyword">from</span> <span class="string">'./css/index.css'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用样式时,类名和id选择器的名称都是导入的对象属性</span></span><br><span class="line">&lt;div className=&#123;cssobj.title&#125; id=&#123;cssobj.box&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h5 id="使用localIdendName参数处理生成的类名"><a href="#使用localIdendName参数处理生成的类名" class="headerlink" title="使用localIdendName参数处理生成的类名"></a>使用localIdendName参数处理生成的类名</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 在解析规则后面再加上localIdentName参数</span></span><br><span class="line">&#123;</span><br><span class="line">  test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">  use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 参数代表的意思</span></span><br><span class="line"><span class="comment">// [path]:样式表文件相对于根目录的相对路径</span></span><br><span class="line"><span class="comment">// [name]:样式表文件的名称</span></span><br><span class="line"><span class="comment">// [local]:样式表文件中选择器的名称</span></span><br><span class="line"><span class="comment">// [hash:5]:随机5位字符串,防止重复</span></span><br></pre></td></tr></table></figure>
<h5 id="解析less"><a href="#解析less" class="headerlink" title="解析less"></a>解析less</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装less less-loader</span></span><br><span class="line">yarn add less less-loader --dev</span><br><span class="line"><span class="comment">// 2. 在webpack.config.js中添加解析规则</span></span><br><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/.less$/</span>,</span><br><span class="line">    use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解析scss"><a href="#解析scss" class="headerlink" title="解析scss"></a>解析scss</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装node-sass sass-loader</span></span><br><span class="line">yarn add node-sass sass-loader --dev</span><br><span class="line"><span class="comment">// 2. 在webpack.config.js中添加解析规则</span></span><br><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/.scss$/</span>,</span><br><span class="line">    use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'sass-loader'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解析字体图标或者图片"><a href="#解析字体图标或者图片" class="headerlink" title="解析字体图标或者图片"></a>解析字体图标或者图片</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装file-loader url-loader</span></span><br><span class="line">yarn add file-loader url-loader --dev</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在webpack.config.js中添加解析规则</span></span><br><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.ttf|woff|svg|woff2|eot$/</span>, <span class="comment">// 解析字体图标</span></span><br><span class="line">    <span class="comment">// test:/\.png|jpg|bmp|gif$/,</span></span><br><span class="line">    use:<span class="string">'url-loader?limit=5000'</span></span><br><span class="line">    <span class="comment">// 如果文件被打包成base64的字符串,只会使用url-loader</span></span><br><span class="line">    <span class="comment">// 如果文件被打包成为路径嵌入到js中,会使用url-loader和file-loader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><blockquote>
<p>注意: </p>
<ol>
<li>绑定事件时必须使用箭头函数进行包裹业务逻辑函数,目的是为了传参方便</li>
<li>定义业务逻辑处理函数必须使用箭头函数进行定义,目的是让函数内部this总是指向当前组件实例</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 绑定事件使用空的箭头函数包裹自己定义的一个实例方法</span></span><br><span class="line">&lt;button onClick=&#123; ()=&gt;&#123; <span class="keyword">this</span>.btnClick(<span class="number">123</span>) &#125;&#125;&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 2. 定义实例方法的时候,使用箭头函数进行定义</span></span><br><span class="line"><span class="regexp">btnClick = (arg)=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    console.log(this.state.msg)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="单向数据流-1"><a href="#单向数据流-1" class="headerlink" title="单向数据流"></a>单向数据流</h3><h4 id="setState-数据更新"><a href="#setState-数据更新" class="headerlink" title="setState()数据更新"></a>setState()数据更新</h4><blockquote>
<p>在react中如果需要修改state中的数据,需要使用<code>this.setState({})</code>进行修改，只有这种方式对数据进行修改之后，可以触发视图的更新。</p>
<p>注意: <code>this.setState({})</code>方法是一个<strong>异步方法</strong>,如果需要在修改数据之后离开对数据进行使用，需要提供第二个参数-回调函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">btnClick = <span class="function">(<span class="params">arg</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="comment">// this.setState(&#123;</span></span><br><span class="line">     <span class="comment">//   msg:'hello'</span></span><br><span class="line">     <span class="comment">// &#125;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg:<span class="number">123</span></span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.msg)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="受控表单"><a href="#受控表单" class="headerlink" title="受控表单"></a>受控表单</h4><blockquote>
<p>React中的表单元素只要添加了value属性,就不能由用户在界面中对表单的值进行修改,必须通过JS代码对数据进行修改,这种表单就叫做<strong>受控表单</strong></p>
<p>单向数据流里面如果希望实现类似于双向数据绑定额功能,其实主要就是需要程序员自己手动写代码去实现视图到模型的数据更新这一块功能。</p>
<p>实现思路:一般都是监听表单的值改变事件(onChange)，在这个事件中将视图中的数据赋值给模型中成员。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    	&lt;input value = &#123;this.state.msg&#125; onChange = &#123; (e) =&gt; this.valueChange(e) &#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valueChange(e)&#123;</span><br><span class="line">    // 1. 获取用户输入的文本框内容</span><br><span class="line">    const value = e.taget.value</span><br><span class="line">    // 2. 使用this.setState(&#123;&#125;)修改msg的数据</span><br><span class="line">    this.setSatte(&#123;</span><br><span class="line">        msg:value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ref-获取DOM引用"><a href="#ref-获取DOM引用" class="headerlink" title="ref 获取DOM引用"></a>ref 获取DOM引用</h4><blockquote>
<p>如果在开发中需要操作DOM,可以改DOM标签添加一个ref属性,属性值是字符串,然后通过<code>this.refs.xxx</code>可以直接获取当前这个DOM对象的引用。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    	&lt;input ref = 'inp' value = &#123;this.state.msg&#125; onChange = &#123; () =&gt; this.valueChange() &#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">valueChange(e)&#123;</span><br><span class="line">    // 1. 获取用户输入的文本框内容</span><br><span class="line">    // 1.1 使用this.refs.inp获取到DOM引用</span><br><span class="line">    const target = this.refs.inp</span><br><span class="line">    // 1.2 再通过DOM对象的value属性获取到文本框的值</span><br><span class="line">    const value = taget.value</span><br><span class="line">    // 2. 使用this.setState(&#123;&#125;)修改msg的数据</span><br><span class="line">    this.setSatte(&#123;</span><br><span class="line">        msg:value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="属性校验"><a href="#属性校验" class="headerlink" title="属性校验"></a>属性校验</h4><blockquote>
<p>属性校验是在组件内部对传进来的外界属性的类型进行校验,主要是为了增加程序的健壮性，当传递数据的类型不符合要求时,可以在控制台做出警告提示。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装prop-types模块并导入</span></span><br><span class="line">yarn add prop-types</span><br><span class="line"><span class="keyword">import</span> Types <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在组件内部定义静态属性propTypes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Componnet</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2.1 静态属性 propTypes 设置需要校验的属性</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">        <span class="comment">// count 这个属性值只接受数值类型</span></span><br><span class="line">        count:Types.number,</span><br><span class="line">        msg:Types.string.isRequired</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.2 静态属性 defaultProps 设置需要校验的属性的默认值</span></span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">		count:<span class="number">0</span>,</span><br><span class="line">        msg:<span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数(不属于生命周期函数)</span></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">		<span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Componnet</span></span>&#123;</span><br><span class="line">	<span class="comment">// 构造函数(不属于生命周期函数)</span></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">		<span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 组件的创建阶段(3个函数) */</span> </span><br><span class="line">    <span class="comment">// 执行时机: 组件在内存中被创建出来，然后所有的属性和实例方法都已经挂载完毕</span></span><br><span class="line">    <span class="comment">// 特点(只执行1次): 可以访问当前组件的属性和方法,通常用于数据初始化和发送异步请求(类似vue的created)</span></span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 执行时机：当前组件需要被渲染到真实页面时执行,此时仅仅只是在内存中建立好了虚拟DOM对象</span></span><br><span class="line">    <span class="comment">// 特点(1次以上): 用于创建当前组件的DOM结构</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                jsx虚拟DOM</span><br><span class="line">            &lt;<span class="regexp">/div&gt;)</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 执行时机: 数据全部挂载完毕,同时所有的虚拟DOM都已经被渲染成真实DOM</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 特点(只执行1次)：可以在这个函数中操作真实DOM(类似vue中的mounted)</span></span><br><span class="line"><span class="regexp">    componentDidMount()&#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span>* 组件的运行阶段(<span class="number">4</span>个函数) *<span class="regexp">/ </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 执行时机: 组件所接收的外界数据props发生变化的时候触发</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 特点: 在这个函数中可以通过形参nextProps获取到最新的props数据</span></span><br><span class="line"><span class="regexp">    componentWillReceiveProps(nextProps)&#123;</span></span><br><span class="line"><span class="regexp">		/</span><span class="regexp">/ this.props里面是旧值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ nextProps里面是最新的值</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 执行时机: state或props中的数据发生变化时会触发该函数</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 特点: 根据该函数内部return值决定组件是否需要被重新更新(渲染)</span></span><br><span class="line"><span class="regexp">    shouldComponentUpdate(nextProps,nextState)&#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ this.state.xxx 旧值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ nextSatte 新值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ this.props.xxx 旧值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ nextProps 新值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ return true会执行后续生命周期函数,会重新渲染组件</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ return false不会执行后续生命周期,组件不会重新渲染</span></span><br><span class="line"><span class="regexp">		return true</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 执行时机: 当shouldComponentUpdate内部return true时会执行该函数</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 特点: 当前组件的状态(props,state)已经是最新值,但是DOM中绑定的数据还是旧值，即DOM还没有被更新(类似vue中的beforeUpdate)</span></span><br><span class="line"><span class="regexp">    componentWillUpdate()&#123;</span></span><br><span class="line"><span class="regexp">		/</span><span class="regexp">/ this.state.xxx 新值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ this.props.xxx 新值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 真实DOM中的数据还是旧的</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/ 注意: componentWillUpdate 执行完毕之后会立刻重新执行 render 函数,然后将最新数据渲染到虚拟DOM中</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/ 执行时机: 虚拟DOM被渲染到真实DOM中会执行该函数</span></span><br><span class="line"><span class="regexp">   	/</span><span class="regexp">/ 特点: 组件的状态和当前DOM界面都是最新的,已经完成了同步(类似vue中的updated)</span></span><br><span class="line"><span class="regexp">    componentDidUpdate()&#123;</span></span><br><span class="line"><span class="regexp">		/</span><span class="regexp">/ this.state.xxx 新值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ this.props.xxx 新值</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 真实DOM中的数据还是新的</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">    /</span>* 组件销毁阶段(<span class="number">1</span>个函数) *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 执行时机: 组件即将被销毁,但是还没有被销毁时执行</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 特点: 还可以继续访问组件的属性和方法,在这个函数中可以做一些数据的清理工作,防止内存泄露</span></span><br><span class="line"><span class="regexp">    componentWillUnmount()&#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="promise的封装"><a href="#promise的封装" class="headerlink" title="promise的封装"></a>promise的封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个函数,函数内部return一个promise实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 2. 在promise实例内部执行真正的异步操作(网络请求、定时器)</span></span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url:<span class="string">'http://www.lovegf.cn:8899'</span>,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 2.1 异步操作成功时,调用resolve函数将数据返回</span></span><br><span class="line">          resolve(data)</span><br><span class="line">        &#125;,</span><br><span class="line">        fail:<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">          <span class="comment">// 2.2 异步操作失败时,调用reject函数将错误返回</span></span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 调用封装好的函数时使用.then接收数据</span></span><br><span class="line">fetch().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	consloe.log(data)</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">	consloe.log(data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用async和await 简化promise的调用</span></span><br><span class="line"><span class="comment">// 4.1. 定义一个使用async修饰的函数</span></span><br><span class="line"><span class="keyword">async</span> fetch_async()&#123;</span><br><span class="line">    <span class="comment">// 4.2. 在这个函数内部使用await修饰能够返回promise实例的函数的调用</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> fetch()</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h3><blockquote>
<p><code>HashRouter</code> 用于指定当前项目中使用哪一种路由模式</p>
<p><code>Route</code> 用于配置路由规则,同时当做路由占位符</p>
<p><code>Link</code> 用于设置路由跳转链接，使用to属性指定跳转路径</p>
<hr>
<p>注意:</p>
<ol>
<li><code>HashRouter</code>用于指定路由模式,在项目中只使用一次,而且其内部只能有一个根元素</li>
<li><code>Route</code>用于配置路由规则,同时也是路由占位符</li>
<li><code>exact</code>属性可以设置路由规则被精确匹配</li>
</ol>
</blockquote>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 安装react-router-dom</span></span><br><span class="line">yarn add react-router-dom</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在项目根组件中导入路由组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'@/components/Hello.jsx'</span></span><br><span class="line"><span class="keyword">import</span> CommentList <span class="keyword">from</span> <span class="string">'@/components/CommentList.jsx'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用Route创建路由规则</span></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;HashRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        	&lt;Link to='/home'&gt;首页&lt;/Link&gt;</span><br><span class="line">            &lt;Link to='/list'&gt;列表&lt;/Link&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;Route path='/home' component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">            &lt;Route path='/list' component=&#123;List&#125;&gt;&lt;/Route&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一:params传参</span></span><br><span class="line"><span class="comment">// 1. 设置跳转路径(12345是实参)</span></span><br><span class="line">&lt;Link to=<span class="string">'/list/12345'</span>&gt;列表&lt;<span class="regexp">/Link&gt; 或者</span></span><br><span class="line"><span class="regexp">this.props.hitory.push('/</span>list/<span class="number">12345</span><span class="string">')</span></span><br><span class="line"><span class="string">// 2. 设置路由规则(:id是形参)</span></span><br><span class="line"><span class="string">&lt;Route path='</span>/list/:id/:type/:tag<span class="string">' component=&#123;List&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">// 3. 在路由对应的组件中获取参数</span></span><br><span class="line"><span class="string">console.log(this.props.match.params.id) // 12345</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">// 方式二:query传参</span></span><br><span class="line"><span class="string">// 特点:不需在再路由规则中添加形参;在地址栏中看不到传递的参数</span></span><br><span class="line"><span class="string">// 1. 设置跳转路径</span></span><br><span class="line"><span class="string">&lt;Link to=&#123;&#123;pathname:'</span>/list<span class="string">',query:&#123;id:12345,type:'</span>movie<span class="string">'&#125;&#125;&#125;&gt;列表&lt;/Link&gt; 或者</span></span><br><span class="line"><span class="string">this.props.hitory.push(&#123;pathname:'</span>/list<span class="string">',query:&#123;id:12345,type:'</span>movie<span class="string">'&#125;&#125;)</span></span><br><span class="line"><span class="string">// 2. 设置路由规则</span></span><br><span class="line"><span class="string">&lt;Route path='</span>/list<span class="string">' component=&#123;List&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">// 3. 在路由对应的组件中获取参数</span></span><br><span class="line"><span class="string">console.log(this.props.location.query.type) // movie</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">// 方式三:state传参</span></span><br><span class="line"><span class="string">// 特点:不需要在路由规则中添加形参;在地址栏中看不到传递的参数；可以将参数缓存,刷新页面参数也会存在</span></span><br><span class="line"><span class="string">// 1. 设置跳转路径</span></span><br><span class="line"><span class="string">&lt;Link to=&#123;&#123;pathname:'</span>/list<span class="string">',state:&#123;id:12345,type:'</span>movie<span class="string">'&#125;&#125;&#125;&gt;列表&lt;/Link&gt; 或者</span></span><br><span class="line"><span class="string">this.props.hitory.push(&#123;pathname:'</span>/list<span class="string">',state:&#123;id:12345,type:'</span>movie<span class="string">'&#125;&#125;)</span></span><br><span class="line"><span class="string">// 2. 设置路由规则</span></span><br><span class="line"><span class="string">&lt;Route path='</span>/list<span class="string">' component=&#123;List&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">// 3. 在路由对应的组件中获取参数</span></span><br><span class="line"><span class="string">console.log(this.props.location.state.type) // movie</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 方式四:search传参</span></span><br><span class="line"><span class="string">&lt;Link to=&#123;&#123;pathname:'</span>/list?id=<span class="number">12345</span>&amp;type=movie<span class="string">'&#125;&#125;&gt;列表&lt;/Link&gt; 或者</span></span><br><span class="line"><span class="string">this.props.hitory.push(&#123;pathname:'</span>/list?id=<span class="number">12345</span>&amp;type=movie<span class="string">')</span></span><br><span class="line"><span class="string">// 2. 设置路由规则</span></span><br><span class="line"><span class="string">&lt;Route path='</span>/list<span class="string">' component=&#123;List&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">// 3. 在路由对应的组件中获取参数</span></span><br><span class="line"><span class="string">console.log(this.props.location.search) // ?id=12345&amp;type=movie</span></span><br><span class="line"><span class="string">// id=12345&amp;type=movie</span></span><br><span class="line"><span class="string">// [id=12345,type=movie]</span></span><br><span class="line"><span class="string">// &#123;id:12345,type:'</span>movie<span class="string">'&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入路由重定向组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Link, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用Route组件上的render函数实现重定向</span></span><br><span class="line">render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;HashRouter&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        	&lt;Link to='/home'&gt;首页&lt;/Link&gt;</span><br><span class="line">            &lt;Link to='/list'&gt;列表&lt;/Link&gt;</span><br><span class="line">            </span><br><span class="line">          	&#123;/* 访问根路径 / 时 会跳转到 /home*/&#125;  </span><br><span class="line">            &lt;Route path='/' render=&#123;() =&gt; &lt;Redirect to='/home'/&gt;&#125; exact&gt;&lt;/Route&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;Route path='/home' component=&#123;Home&#125; exact&gt;&lt;/Route&gt;</span><br><span class="line">            &lt;Route path='/list' component=&#123;List&#125; exact&gt;&lt;/Route&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/HashRouter&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><blockquote>
<p>React路由嵌套实现的是每个组件中都可以定义路由规则</p>
<p>A组件对应的路由是 ‘/home’ <code>&lt;Route path=&#39;/home&#39; component={A}&gt;&lt;/Route&gt;</code></p>
<p>A组件内部如果又定义了路由规则  <code>&lt;Route path=&#39;/newslist&#39; component={B}&gt;&lt;/Route&gt;</code></p>
<p>路由规则 <code>/newslist</code> 是<code>/home</code>的子路由,同时B组件也是A组件的子组件。</p>
</blockquote>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作业一:</span><br><span class="line">使用antd-movie搭建移动端项目(http:<span class="comment">//vue.lovegf.cn) 不需要用嵌套路由</span></span><br><span class="line">作业二:</span><br><span class="line">使用antd搭建pc端后台管理系统(http:<span class="comment">//oa.lovegf.cn) 必须要用到嵌套路由</span></span><br></pre></td></tr></table></figure>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><blockquote>
<p><code>fetch</code>是window对象下的一个新的API,和<code>XMLHttpRequest</code>作用一样,是专门用来发送异步请求。</p>
<p>fetch特点:</p>
<ol>
<li>是基于promise封装的,语法简洁</li>
<li><code>fetch</code>支持同构(跨平台)，可以在移动设备上运行</li>
</ol>
</blockquote>
<h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'http://www.lovegf.cn:8899/api/getlunbo'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application/x-www-form-urlencoded // name=zs&amp;age=18</span></span><br><span class="line"><span class="comment">// application/json // &#123;name:'zs',age:18&#125;</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'http://www.lovegf.cn:8899/api/addproduct'</span>,&#123;</span><br><span class="line">    method:<span class="string">"POST"</span>,</span><br><span class="line">    body:&#123;</span><br><span class="line">        content:<span class="string">'zs'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>res.json())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 全局安装create-react-app</span></span><br><span class="line">yarn global add create-react-app 或者 cnpm i create-react-app -g</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 初始化项目模板</span></span><br><span class="line">create-react-app react_project</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 运行项目</span></span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="jsx有状态组件代码片段"><a href="#jsx有状态组件代码片段" class="headerlink" title="jsx有状态组件代码片段"></a>jsx有状态组件代码片段</h3><blockquote>
<p>将以下代码复制到javascriptreact.json文件中</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"jsx"</span>: &#123;</span><br><span class="line">		<span class="attr">"prefix"</span>: <span class="string">"jsx"</span>,</span><br><span class="line">		<span class="attr">"body"</span>: [</span><br><span class="line">			<span class="string">"import React from 'react'\r"</span>,</span><br><span class="line">			<span class="string">"\r"</span>,</span><br><span class="line">			<span class="string">"export default class $&#123;1:ComName&#125; extends React.Component &#123;\r"</span>,</span><br><span class="line">			<span class="string">"  constructor()&#123;\r"</span>,</span><br><span class="line">			<span class="string">"    super()\r"</span>,</span><br><span class="line">			<span class="string">"    this.state = &#123;\r"</span>,</span><br><span class="line">			<span class="string">"       $3\r"</span>,</span><br><span class="line">			<span class="string">"    &#125;\r"</span>,</span><br><span class="line">			<span class="string">"  &#125;\r"</span>,</span><br><span class="line">			<span class="string">"  render()&#123;\r"</span>,</span><br><span class="line">			<span class="string">"    return &lt;div&gt;\r"</span>,</span><br><span class="line">			<span class="string">"        绝云气,负青天$4\r"</span>,</span><br><span class="line">			<span class="string">"    &lt;/div&gt;\r"</span>,</span><br><span class="line">			<span class="string">"  &#125;\r"</span>,</span><br><span class="line">			<span class="string">"&#125;"</span></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"description"</span>: <span class="string">"创建react有状态组件"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/UI/使用MUI遇到的坑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/UI/使用MUI遇到的坑/" itemprop="url">MUI使用过程遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-10T11:07:04+08:00">
                2019-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用MUI遇到的问题"><a href="#使用MUI遇到的问题" class="headerlink" title="使用MUI遇到的问题"></a>使用MUI遇到的问题</h2><h4 id="一。制作顶部滑动条的坑们："><a href="#一。制作顶部滑动条的坑们：" class="headerlink" title="一。制作顶部滑动条的坑们："></a>一。制作顶部滑动条的坑们：</h4><ol>
<li><p>需要借助于 MUI 中的 tab-top-webview-main.html </p>
</li>
<li><p>需要把 slider 区域的 mui-fullscreen 类去掉</p>
</li>
<li><p>滑动条无法正常触发滑动，通过检查官方文档，发现这是JS组件，需要被初始化一下：<br>#</p>
</li>
</ol>
<ul>
<li><p>导入 mui.js </p>
</li>
<li><p>调用官方提供的 方式 去初始化：</p>
</li>
<li><p>注意： 如果要初始化 滑动条，必须要等 DOM 元素加载完毕，所以，我们把 初始化 滑动条 的代码，搬到了 mounted 生命周期函数中；</p>
<pre><code>mounted（）{

    mui(&apos;.mui-scroll-wrapper&apos;).scroll({

      deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006

});
}
</code></pre></li>
</ul>
<p>4.我们在初始化 滑动条 的时候，导入的 mui.js ，但是，</p>
<p>控制台报错： Uncaught TypeError: ‘caller’, ‘callee’, and ‘arguments’ properties may not be accessed on strict mode</p>
<pre><code>是因为 mui.js 中用到了 &apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; 东西，但是，
 webpack 打包好的 bundle.js 中，默认是启用严格模式的，所以，这两者冲突了；
</code></pre><p>最终，我们选择了 plan B  移除严格模式： 使用这个插件</p>
<pre><code>babel-plugin-transform-remove-strict-mode
</code></pre><p>或者在<code>.babelrc</code>文件中配置下忽略文件(与plugins并齐)：</p>
<pre><code>`&quot;ignore&quot;: [
&quot;./src/lib/mui/js/mui.js&quot;
],`
</code></pre><h4 id="二。mui-js引入之后，底部tab切换的时候产生冲突："><a href="#二。mui-js引入之后，底部tab切换的时候产生冲突：" class="headerlink" title="二。mui.js引入之后，底部tab切换的时候产生冲突："></a>二。mui.js引入之后，底部tab切换的时候产生冲突：</h4><p>当 滑动条 调试OK后，发现，下面的 tabbar 点击切换组件的时候，无法正常切换，把引入进来的mui.js注释之后又恢复正常了，</p>
<p>是因为js和css文件里两者类样式名可能产生了冲突，需要把 每个 tabbar 按钮的 样式中  mui-tab-item 重新改一下名字，把里面的样式复制下来即可；</p>
<h4 id="三。使用MUI"><a href="#三。使用MUI" class="headerlink" title="三。使用MUI"></a>三。使用MUI</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/安装yarn/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/安装yarn/" itemprop="url">yarn安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-10T11:07:04+08:00">
                2019-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>1.全局安装yarn</p>
<p>  npm i yarn -g</p>
</li>
<li><p>2.新增环境变量</p>
<ul>
<li><p>在 sysdm.cpl 控制面板–系统属性–高级–环境变量–系统变量–Path双击–新键，</p>
</li>
<li><p>把cmder所在目录 路径 复制过去 （文件名路径不能含中文）</p>
</li>
<li><p>确定保存之后 直接通过右键 Cmder here 执行命令 </p>
</li>
<li><p>yarn 命令</p>
</li>
<li><p>比如 yarn add sass-loader node-sass –dev</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>3.通过npm下载的全局包 查看:</p>
<p>   C:\Users\ASUS\AppData\Roaming\npm</p>
<p>  通过yarn下载的全局包:</p>
<p>   yarn global add http-server</p>
</li>
<li><p>4.yarn 下载的包存储在 C:\Users\ASUS\AppData\Local\bin中，同样去系统变量中配置一下</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/用手机测试项目/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/用手机测试项目/" itemprop="url">在手机上测试自己项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T18:50:00+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="尝试在手机上-去进行项目的预览和测试"><a href="#尝试在手机上-去进行项目的预览和测试" class="headerlink" title="尝试在手机上 去进行项目的预览和测试"></a>尝试在手机上 去进行项目的预览和测试</h2><ol>
<li><p>要保证自己的手机可以正常运行；</p>
</li>
<li><p>要保证 手机 和 开发项目的电脑 处于同一个 WIFI 环境中，也就是说 手机 可以 访问到 电脑的 IP</p>
</li>
<li><p>打开自己的 项目中 package.json 文件，在 dev 脚本中，添加一个 –host 指令， 把 当前 电脑的 WIFI IP地址， 设置为 –host 的指令值；</p>
</li>
<li><p>如何查看自己电脑所处 WIFI 的IP呢， 在 cmd 终端中运行 ipconfig ， 查看 无线网的 ip 地址</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/08/vue/vueday12/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/08/vue/vueday12/" itemprop="url">12 编程式的导航(使用js形式进行路由导航 this.$router.push)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-08T18:35:00+08:00">
                2019-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h2><ul>
<li><p>除了使用 <router-link> 创建 a 标签来定义导航链接，还可以借助 router 的实例方法，通过编写代码来实现</router-link></p>
</li>
<li><p>在 Vue 实例内部，通过 $router 访问路由实例。可以调用 this.$router.push</p>
</li>
</ul>
<p>1.在网页中，有两种跳转方式：</p>
<p>   方式1： 使用 a 标签 的形式叫做 标签跳转 </p>
<p>   方式2： 使用 window.location.href 的形式，叫做 编程式导航 </p>
<p>2.使用JS的形式进行路由导航</p>
<p>   注意： 一定要区分 this.$route 和 this.$router 这两个对象，</p>
<p>   其中： this.$route 是路由【参数对象】，所有路由中的参数， params, query 都属于它</p>
<p>   其中： this.$router 是一个路由【导航对象】，用它 可以方便的 使用 JS 代码，实现路由的 前进、后退、 跳转到新的 URL 地址，这里面的this.$router指的是当前项目中的router实例</p>
<pre><code>console.log(this);

 1. 最简单的 // 字符串
this.$router.push(&quot;/home/goodsinfo/&quot; + id);

2. 传递对象  // 对象 （如果使用path进行跳转，需要携带参数，必须自行手动拼接，path不能和params一起使用，如果传入了path 则params 无效）
this.$router.push({ path: &quot;/home/goodsinfo/&quot; + id });

3. 传递命名的路由  // 命名的路由（params 只能和name同时使用）
this.$router.push({ name: &quot;goodsinfo&quot;, params: { id } });
</code></pre><h2 id="抽取组件要注意的事项"><a href="#抽取组件要注意的事项" class="headerlink" title="抽取组件要注意的事项"></a>抽取组件要注意的事项</h2><p>如果抽取组件之后，使用的时候，有部分组件比如宽高有冲突：</p>
<p>首页中的轮播图 和 详情中的轮播图，分歧点是 宽度到底是 100% 还是 自适应，</p>
<pre><code>   &lt;script&gt;
       export default {
         props: [&quot;lunbotuList&quot;, &quot;isfull&quot;]
       };
   &lt;/script&gt;

.full {width: 100%;}

&lt;img :src=&quot;item.img&quot; alt=&quot;&quot; :class=&quot;{&apos;full&apos;: isfull}&quot;&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/vue/vueday11/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/vue/vueday11/" itemprop="url">11 mui滑动插件的bug处理方案 vue-preview插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-05T18:10:00+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vue-day11"><a href="#vue-day11" class="headerlink" title="vue day11"></a>vue day11</h2><h3 id="VSCode快捷键"><a href="#VSCode快捷键" class="headerlink" title="VSCode快捷键"></a>VSCode快捷键</h3><ol>
<li><p>向上/下移动代码片段</p>
<p> alt + 上箭头或下箭头</p>
</li>
<li><p>向上/下复制代码片段</p>
<p> alt + shift + 上箭头或下箭头</p>
</li>
<li><p>换至下一行</p>
<p> ctrl + enter</p>
</li>
<li><p>换至上一行</p>
<p> ctrl + shift + enter</p>
</li>
<li><p>删除选中行</p>
<p> ctrl + shift + k</p>
</li>
<li><p>关闭当前窗口</p>
<p> ctrl + w</p>
</li>
</ol>
<h3 id="mui滑动插件的bug处理方案"><a href="#mui滑动插件的bug处理方案" class="headerlink" title="mui滑动插件的bug处理方案"></a>mui滑动插件的bug处理方案</h3><p>babel的目的是将ES6或更高级的语法转换为ES5的语法</p>
<p>在使用babel5以上时, 默认会将每个js文件加上 <code>&#39;use strict&#39;</code> 开启严格模式, 而<code>mui</code>中使用了<code>arguments</code>, 所以会报错</p>
<p>方案1: 放弃mui   舍弃</p>
<p>方案2: 关闭babel默认开启的严格模式   目前版本(babel6及以上) 已经无法通过插件关闭严格模式了  故 舍弃</p>
<p>方案3: 忽略某个文件   采用此方案</p>
<p>在<code>.babelrc</code>的配置文件中, 添加ignore节点:</p>
<pre><code>{
  &quot;presets&quot;: [
    [&quot;env&quot;, {
      &quot;modules&quot;: false,
      &quot;targets&quot;: {
        &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;]
      }
    }],
    &quot;stage-2&quot;
  ],
  &quot;ignore&quot;: [
    &quot;./src/lib/mui/js/mui.js&quot;
  ]
}
</code></pre><h3 id="vue-preview插件的注意事项"><a href="#vue-preview插件的注意事项" class="headerlink" title="vue-preview插件的注意事项"></a>vue-preview插件的注意事项</h3><ul>
<li><p>由于vue-preview插件已经更新, 所以调整样式很麻烦, 这里推荐使用插件 vue2-preview, 这是一个机制的小伙子保留下来的旧版本插件</p>
</li>
<li><p>但是这个机制的小伙子也更新了插件, 所以选择vue2-preview的1.0.2的版本进行使用</p>
</li>
</ul>
<ol>
<li><p>装包</p>
<pre><code>npm i vue2-preview@1.0.2 -S
</code></pre></li>
<li><p>配置loader</p>
<p> 如果你是使用vue-cli生成的项目，可能需要你修改webpack.base.conf.js文件中的loaders，添加一个loader。 原因：插件编写中使用了es6的语法，需要进行代码编译</p>
<pre><code>{
    test: /vue-preview.src.*?js$/,
    loader: &apos;babel&apos;
}
</code></pre></li>
<li><p>安装插件</p>
<pre><code>import VuePreview from &apos;vue2-preview&apos;
Vue.use(VuePreview)
</code></pre></li>
<li><p>使用案例</p>
<pre><code>&lt;template&gt;
  &lt;img class=&quot;preview-img&quot; v-for=&quot;(item, index) in list&quot; :src=&quot;item.src&quot; height=&quot;100&quot; @click=&quot;$preview.open(index, list)&quot;&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data () {
      return {
        list: [{
          src: &apos;https://placekitten.com/600/400&apos;,
          w: 600,
          h: 400
        }, {
          src: &apos;https://placekitten.com/1200/900&apos;,
          w: 1200,
          h: 900
        }]
      }
    }
  }
&lt;/script&gt;
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/30/vue/vueday09/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/vue/vueday09/" itemprop="url">09 vue-cli 脚手架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-30T22:20:04+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vue-day09"><a href="#vue-day09" class="headerlink" title="vue day09"></a>vue day09</h2><h3 id="vue-cli-脚手架"><a href="#vue-cli-脚手架" class="headerlink" title="vue-cli 脚手架"></a>vue-cli 脚手架</h3><ol>
<li><p>装包</p>
<p> 全局安装 <code>webpack</code> 和 <code>webpack-cli</code></p>
<pre><code>npm i webpack webpack-cli -g
</code></pre><p> 全局安装 <code>vue-cli</code> 脚手架包</p>
<pre><code>npm i vue-cli -g
</code></pre></li>
<li><p>使用脚手架命令新建一个<code>webpack</code>工程化的<code>vue</code>项目</p>
<p> 找一个风水宝地</p>
<pre><code>vue init webpack 项目名称(目录名称)
</code></pre><p> 例如:</p>
<pre><code>PS C:\Users\LTC\Desktop&gt; vue init webpack vue-cms

? Project name vue-cms
? Project description 这是一个高端项目
? Author TianchengLee &lt;ltc6634284@gmail.com&gt;
? Vue build runtime
? Install vue-router? Yes
? Use ESLint to lint your code? Yes 建议选No
? Pick an ESLint preset Standard
? Set up unit tests No
? Setup e2e tests with Nightwatch? No
? Should we run `npm install` for you after the project has been created? (recommended) npm
</code></pre></li>
<li><p>执行以上向导完成后, 会自动开始装包, 注意: 使用的是<code>npm install</code>, 速度可能会比较慢</p>
<p> 如果安装失败, 建议ctrl + C终止后执行<code>cnpm i</code></p>
</li>
<li><p>安装完成后所有的webpack配置都已配好, 注意: 但是所有的样式预处理loader都没有安装, 需要使用less就安装less和less-loader, 无需自己配置, 只需要安装即可</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/30/vue/vueday08/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/30/vue/vueday08/" itemprop="url">08 vue babel,render函数的使用 模块化vue组件 使用webpack引入vue和vue-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-30T22:20:04+08:00">
                2018-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vue-day08"><a href="#vue-day08" class="headerlink" title="vue day08"></a>vue day08</h2><h3 id="babel的使用"><a href="#babel的使用" class="headerlink" title="babel的使用"></a>babel的使用</h3><ol>
<li><p>装核心包和loader的包</p>
<p> <strong>注意事项</strong>: 由于<code>babel-loader</code>和<code>babel-core</code>已经更新, <code>babel-core</code>换了个包名, 最新版的包名是<code>@babel/core</code>, 最新版本的<code>babel-core</code>必须结合最新版本的<code>babel-loader</code>使用, 也就是<code>babel-core7</code>结合<code>babel-loader8</code>使用, 而<code>npm i babel-loader babel-core -D</code> 这个指令安装的是<code>babel-loader8</code> 和 <code>babel-core6</code>, 所以会导致<code>babel</code>无法使用, 需要手动将<code>babel-loader</code>的版本降为 7</p>
<p> 总结:</p>
<pre><code>npm i babel-loader@7 babel-core -D
</code></pre></li>
<li><p>装语法的包</p>
<p> 由于babel默认只能将一部分ES6语法转为ES5, 所以还需要根据自身的需求选择语法预设 (preset)</p>
<p> 必须要装的是<code>env</code>, <code>stage-X</code>可以选装, 但是如果需要用更高级的ES6语法, 建议都装</p>
<p> 不推荐使用最新版本的插件而放弃stage, 这样你会多很多工作</p>
<pre><code>npm i babel-preset-env babel-preset-stage-0 -D
</code></pre></li>
<li><p>在<code>webpack.config.js</code>中配置好loader</p>
<pre><code>module: {
    rules: [
      { test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] },
      // less-loader
      { test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] },
      { test: /\.(scss|sass)$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] },
      {
        test: /\.(png|jpg|gif|jpeg|bmp|webp)$/,
        use: [&apos;url-loader?limit=8192&amp;name=[hash:8]-[name].[ext]&apos;]
        // use: [
        //   {
        //     loader: &apos;url-loader&apos;,
        //     options: {
        //       limit: 8192 // 限制 单位为byte  8192字节是8KB
        //     }
        //   }
        // ]
      },
      { test: /\.(eot|svg|ttf|woff|woff2)$/, use: [&apos;url-loader&apos;] },
      { test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loader&apos; }
    ]
  },
</code></pre></li>
<li><p>在项目根目录新建一个<code>.babelrc</code>配置文件, 并在其中配置好语法预设</p>
<pre><code>{
  &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;]
}
</code></pre></li>
</ol>
<h3 id="render函数的使用"><a href="#render函数的使用" class="headerlink" title="render函数的使用"></a>render函数的使用</h3><p>创建VM实例时, 指定el属性来设置VM实例的托管区域, 以后可以将注册的组件在托管区域内以标签形式来使用</p>
<p>如果使用render函数, 则是将指定的某个组件, 直接替换掉托管区域(app)</p>
<p>传统的component方式:</p>
<pre><code>var login = {
  template: &apos;&lt;h1&gt;这是登录组件&lt;/h1&gt;&apos;
}

// 创建 Vue 实例，得到 ViewModel
var vm = new Vue({
  el: &apos;#app&apos;,
  data: {},
  methods: {},
  components: {
    login
  }
});
</code></pre><p>使用render函数渲染组件:</p>
<pre><code>var login = {
    template: &apos;&lt;h1&gt;这是登录组件&lt;/h1&gt;&apos;
}

var vm = new Vue({
    el: &apos;#app&apos;,
    data: {},
    methods: {},
    render: function(createElement) {
        return createElement(login)
    }
})
</code></pre><p>简写:</p>
<pre><code>var login = {
    template: &apos;&lt;h1&gt;这是登录组件&lt;/h1&gt;&apos;
}

var vm = new Vue({
    el: &apos;#app&apos;,
    data: {},
    methods: {},
    render: c =&gt; c(login)
})
</code></pre><h3 id="使用webpack引入vue"><a href="#使用webpack引入vue" class="headerlink" title="使用webpack引入vue"></a>使用webpack引入vue</h3><ol>
<li><p>安装</p>
<pre><code>npm i vue -S
</code></pre></li>
<li><p>正在main.js中引入vue</p>
<p> 注意: 如果在main.js中直接引入安装好的vue, 那么默认会引入<code>vue.runtime.common.js</code>而非完整版的vue.js文件</p>
<p> vue包的package.json中配置的main节点如下:</p>
<pre><code>&quot;main&quot;: &quot;dist/vue.runtime.common.js&quot;,
</code></pre></li>
<li><p>在引入vue之前, 先给vue引入起个别名, 指向完整版的vue.js文件</p>
<p> 在webpack.config.js的配置对象中, 新增一个<code>resolve</code>节点, 添加<code>alias</code>属性</p>
<pre><code>resolve: {
    alias: {
      &apos;vue$&apos;: &apos;vue/dist/vue.js&apos;
    }
},
</code></pre></li>
<li><p>在main.js中直接引入vue</p>
<pre><code>import Vue from &apos;vue&apos;
</code></pre></li>
</ol>
<h3 id="模块化vue组件"><a href="#模块化vue组件" class="headerlink" title="模块化vue组件"></a>模块化vue组件</h3><ol>
<li><p>装包</p>
<pre><code>npm i vue-loader vue-template-compiler -D
</code></pre></li>
<li><p>在webpack配置文件中添加匹配规则</p>
<pre><code>{ test: /\.vue$/, use: &apos;vue-loader&apos;}
</code></pre></li>
<li><p>在webpack添加VueLoaderPlugin插件</p>
<p> <strong>注意: 这一个插件是必须的!</strong></p>
<pre><code>const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;)
...
plugins: [ // 插件配置项
    new webpack.HotModuleReplacementPlugin(), // 3. 添加热更新插件
    new HtmlWebpackPlugin({ // 用于帮助我们自动生成HTML文件的
      template: &apos;./src/index.html&apos;, // 如果不指定template, 默认生成一个空的HTML5页面, 指定template表示从哪个HTML文件编译一个新的HTML出来
      filename: &apos;index.html&apos; // 便于开发人员自己查看
    }),
    new VueLoaderPlugin()
],
</code></pre></li>
<li><p>新建vue文件</p>
<p> 注意: vue文件内部有三个节点, 分别是 <code>&lt;template&gt;&lt;/template&gt;</code> 和 <code>&lt;script&gt;&lt;/script&gt;</code> 还有 <code>&lt;style&gt;&lt;/style&gt;</code></p>
<p> 分别表示HTML模板, js代码, 样式, template节点下只能有一个根元素</p>
<p> login.vue:</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;这是通过vue文件写的登录组件!!!&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {

}
&lt;/script&gt;

&lt;style&gt;
h1 {
  color: pink;
}
&lt;/style&gt;
</code></pre></li>
<li><p>在main.js中导入login.vue文件, 以变量接收对象</p>
<pre><code>import login from &apos;./src/login.vue&apos;
</code></pre></li>
<li><p>使用render函数渲染login组件</p>
<pre><code>let vm = new Vue({
  el:&apos;#app&apos;,
  data: {
    msg: &apos;xxx&apos;
  },
  render: c =&gt; c(login)
})
</code></pre><p> <strong>注意</strong>: 使用render函数渲染组件, 可以使用<code>vue.runtime.common.js</code>的vue包, 不会报错</p>
<p> 不过render函数的特点是将app盒子直接替换成login组件</p>
</li>
</ol>
<h3 id="ES6的export和export-default"><a href="#ES6的export和export-default" class="headerlink" title="ES6的export和export default"></a>ES6的export和export default</h3><p>在同一个目录中有两个js文件: <code>m1.js</code> 和 <code>m2.js</code></p>
<p>在ES6中, 导入和导出的语法一共就4种方式:</p>
<pre><code>import *** from *** 例如: import $ from &apos;jquery&apos;
import *** 例如: import &apos;./css/1.css&apos;
export
export default
</code></pre><p>由于开发中会用到模块化, 所以在一个js文件中定义的成员, 需要向外暴露, 就可以使用export或export default</p>
<ol>
<li><p>export default 介绍</p>
<p> 一个js文件, 只能通过 <code>export default</code> 向外暴露一次</p>
<p> 通过 <code>export default</code> 暴露的对象, 可以在 <code>import</code> 的时候手动指定变量名接收, 不需要考虑导出时的变量, 相当于直接把整个数据导出了</p>
<p> 案例: 在<code>m1.js</code>中导出一个对象, 在<code>m2.js</code>中接收</p>
<p> <code>m1.js</code></p>
<pre><code>export default {
    name: &apos;张三&apos;,
    age: 18
} 
</code></pre><p> <code>m2.js</code></p>
<pre><code>import person from &apos;./m1.js&apos;
</code></pre></li>
<li><p>export 介绍</p>
<p> 一般将export称为按需导出</p>
<p> 在一个js文件中, 可以通过<code>export</code>向外暴露多个成员</p>
<p> 通过 <code>export</code> 暴露的成员, 必须定义名称, 而且其他地方导入的时候, 必须按照导出时定义名称来选择导入</p>
<p> 导入时可以通过 <code>as</code> 起别名</p>
<p> 案例: 在<code>m1.js</code>中导出多个数据, 在<code>m2.js</code>中接收</p>
<p> <code>m1.js</code></p>
<pre><code>export let name = &apos;李四&apos;
export let age = 18
export let gender = &apos;男&apos;
export let obj = { name: &apos;对象的名字&apos; }
</code></pre><p> <code>m2.js</code></p>
<pre><code>import { name, age, obj as o } from &apos;./m1.js&apos;
</code></pre></li>
</ol>
<h3 id="在webpack中使用vue-router"><a href="#在webpack中使用vue-router" class="headerlink" title="在webpack中使用vue-router"></a>在webpack中使用vue-router</h3><ol>
<li><p>装包</p>
<pre><code>npm i vue-router -S
</code></pre></li>
<li><p>导入vue-router包并安装到vue身上</p>
<pre><code>import Vue from &apos;vue&apos;
import VueRouter from &apos;vue-router&apos;
// 手动安装到vue身上
Vue.use(VueRouter)
</code></pre></li>
<li><p>创建路由对象</p>
<pre><code>import account from &apos;./componets/account.vue&apos;

let router = new VueRouter({
    routes: [
        { path: &apos;/account&apos;, component: account }
    ]
})
</code></pre></li>
<li><p>将路由对象挂载到vm实例</p>
<pre><code>let vm = new Vue({
    el: &apos;#app&apos;,
    data: {},
    router
})
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/vue/vueday07/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WangXiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王相的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/vue/vueday07/" itemprop="url">07 webpack的配置 webpack-dev-server的使用 HtmlWebpackPlugin的使用 loader</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-28T23:42:04+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="vue-day07"><a href="#vue-day07" class="headerlink" title="vue day07"></a>vue day07</h2><h3 id="webpack基本使用的复习"><a href="#webpack基本使用的复习" class="headerlink" title="webpack基本使用的复习"></a>webpack基本使用的复习</h3><ol>
<li><p>在项目中安装webpack包</p>
<pre><code>npm install -D webpack
npm install -D webpack-cli
</code></pre><p> 注意事项: 如果安装的是4以上的版本, 还需要装<code>cli</code>的包</p>
</li>
</ol>
<ol start="2">
<li><p>在全局安装webpack包</p>
<pre><code>npm install webpack -g
npm install webpack-cli -g
</code></pre></li>
<li><p>使用全局的webpack指令, 编译输出文件</p>
<p> 与webpack3不同, webpack4使用指令时, 必须加上 <code>-o</code> 的参数才可以正确的输出到./dist目录下</p>
<pre><code>webpack main.js -o ./dist/main.js
</code></pre></li>
</ol>
<h3 id="webpack的配置文件"><a href="#webpack的配置文件" class="headerlink" title="webpack的配置文件"></a>webpack的配置文件</h3><p>如果每次执行webpack指令时都需要指定入口和出口, 就太麻烦了, 官方文档也提供了一种配置文件的方式, 只需要在项目的根目录下新建一个名为: <code>webpack.config.js</code> 文件, 并且遵循CommonJS规范对外暴露一个配置对象, 按照官方文档进行配置, 即可每次只需要输入webpack自动查找配置文件进行编译打包:</p>
<p>webpack.config.js文件配置如下:</p>
<pre><code>// 完全遵循了CommonJS规范  这里可以直接写node平台的代码
const path = require(&apos;path&apos;)

module.exports = {
  entry: &apos;./main.js&apos;, // 指定入口, 相对路径和绝对路径均可
  output: {
    path: path.join(__dirname, &apos;./dist&apos;), // 指定出口目录, 必须是绝对路径, 相对路径会报错!!!
    filename: &apos;bundle.js&apos; // 指定出口文件名
  }, // 指定出口, 如果不设置, 默认是 ./dist 目录, 输出入口文件同名的文件
  mode: &apos;development&apos; // 开发  developer 开发者  Programmer 程序员
}
</code></pre><h3 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h3><p>每次修改代码都需要手动运行<code>webpack</code>指令, 不符合开发人员的需求</p>
<p>所以可以结合<code>webpack-dev-server</code>工具, 完成自动化编译打包</p>
<ol>
<li><p>安装<code>webpack-dev-server</code></p>
<p> 必须先安装<code>webpack</code>和<code>webpack-cli</code>在项目开发依赖!</p>
<pre><code>npm i webpack webpack-cli -D
</code></pre><p> 再安装<code>webpack-dev-server</code>到项目开发依赖</p>
<pre><code>npm i webpack-dev-server -D
</code></pre></li>
<li><p>在<code>package.json</code>的<code>scripts</code>节点中配置一个运行脚本</p>
<p> 因为webpack-dev-server是安装在项目开发依赖, 无法全局直接运行, 所以必须在<code>package.json</code>中配置运行脚本</p>
<pre><code>&quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server&quot;
 },
</code></pre></li>
<li><p>配置完脚本后, 通过<code>npm run dev</code>可以运行脚本</p>
<pre><code>npm run dev
</code></pre></li>
</ol>
<h4 id="webpack-dev-server的特点"><a href="#webpack-dev-server的特点" class="headerlink" title="webpack-dev-server的特点"></a>webpack-dev-server的特点</h4><ol>
<li><p>运行<code>npm run dev</code>后, 会启动一个web服务器, 将项目根目录托管到web服务器中，同时监听文件的变化，自动进行打包编译</p>
</li>
<li><p>每当修改了项目中的main.js文件后就会自动编译</p>
</li>
<li><p>编译输出的文件被托管在项目根目录下, 是一个虚拟文件, 通过<code>http://localhost:8080/bundle.js</code>可以直接访问, 但是不会存储在物理磁盘上, 而是放在内存中</p>
<p> 因为放在物理磁盘上影响效率, 而且对磁盘的寿命也有影响</p>
</li>
</ol>
<p>了解了webpack-dev-server的特点后, 在<code>index.html</code>中, 就不能再引入 <code>../dist/bundle.js</code> 而是应该引入, web服务器根目录的<code>bundle.js</code></p>
<pre><code>&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;
</code></pre><p>享受它带来的快感吧!</p>
<p>每次修改了main.js后会自动编译输出到根目录的内存中的bundle.js文件, 同时还支持自动刷新浏览器</p>
<p>注意: webpack-dev-server, 主要作用就是在开发阶段方便程序员频繁修改代码, 自动看效果, 如果项目最终上线, 还是需要使用webpack进行打包编译输出到物理磁盘的dist目录</p>
<h4 id="webpack-dev-server的常用参数"><a href="#webpack-dev-server的常用参数" class="headerlink" title="webpack-dev-server的常用参数"></a>webpack-dev-server的常用参数</h4><pre><code>--open // 自动打开默认浏览器
--port // 自定义端口号
--contentBase // 指定托管的根目录
--hot // 自动更新刷新，热模块替换 HMR Hot Module Replacement
</code></pre><p>在<code>package.json</code>的<code>scripts</code>节点下设置:</p>
<pre><code>&quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase ./src --hot&quot;
 },
</code></pre><h4 id="webpack-dev-server参数写入配置-第二种设置参数的方式"><a href="#webpack-dev-server参数写入配置-第二种设置参数的方式" class="headerlink" title="webpack-dev-server参数写入配置(第二种设置参数的方式)"></a>webpack-dev-server参数写入配置(第二种设置参数的方式)</h4><p>可以不再命令后面使用参数, <code>package.json</code>中直接调用<code>webpack-dev-server</code></p>
<p>在<code>package.json</code>的<code>scripts</code>节点下设置:</p>
<pre><code>&quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server&quot;,
    &quot;dev2&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase ./src --hot&quot;
},
</code></pre><p>配置好之后，可以直接运行启动项目:</p>
<pre><code>npm run dev
</code></pre><p>参数在<code>webpack.config.js</code>文件中的<code>devServer</code>节点中设置:</p>
<pre><code>devServer: {
    contentBase: path.join(__dirname, &apos;src&apos;), // 托管根路径
    compress: true, // 启用压缩
    port: 3000, // 端口号
    open: true, // 自动打开浏览器
    hot: true // 2. 开启热更新  如果设置hot为true 需要手动添加HMR插件, 详见第三步
},
</code></pre><p><strong>注意</strong>: 必须有 <code>webpack.HotModuleReplacementPlugin</code> 才能完全启用 HMR, 如果 <code>webpack</code> 或 <code>webpack-dev-server</code> 是通过 <code>--hot</code> 选项启动的，那么这个插件会被自动添加, 反之需要手动添加HMR插件, 在<code>plugins</code>节点下创建HMR对象即可</p>
<pre><code>// 1. 导入webpack
const webpack = require(&apos;webpack&apos;)

module.exports = {
    // ...
    plugins: [ // 插件配置项
        new webpack.HotModuleReplacementPlugin(), // 3. 添加热更新插件
    ],
}
</code></pre><h3 id="HtmlWebpackPlugin的使用"><a href="#HtmlWebpackPlugin的使用" class="headerlink" title="HtmlWebpackPlugin的使用"></a>HtmlWebpackPlugin的使用</h3><p>因为每次使用物理磁盘的<code>index.html</code>, 还需要考虑<code>bundle.js</code>的位置, <code>DevServer</code>生成的<code>bundle.js</code>在 <code>/</code> 目录, 而<code>webpack</code>打包输出的却在<code>dist</code>目录, 所以容易产生一些困扰, 开发阶段引用根目录, 上线后又要手动换成<code>dist</code>目录, 不太方便</p>
<p><code>HtmlWebpackPlugin</code>帮助我们解决了<code>bundle.js</code>的路径问题</p>
<ol>
<li><p>将<code>index.html</code>托管到内存中的根目录下, 和<code>bundle.js</code>同级</p>
</li>
<li><p>自动添加了<code>bundle.js</code>的引用</p>
</li>
</ol>
<p>使用方法:</p>
<ol>
<li><p>安装插件</p>
<pre><code>npm install --save-dev html-webpack-plugin
</code></pre></li>
<li><p>在<code>webpack.config.js</code>中引入</p>
<pre><code>// 导入HtmlWebpackPlugin
const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)
</code></pre></li>
<li><p>在<code>plugins</code>节点下添加插件</p>
<pre><code>plugins: [ // 插件配置项
    new webpack.HotModuleReplacementPlugin(), // 3. 添加热更新插件
    new HtmlWebpackPlugin({ // 用于帮助我们自动生成HTML文件的
      template: &apos;./src/index.html&apos;, // 如果不指定template, 默认生成一个空的HTML5页面, 指定template表示从哪个HTML文件编译一个新的HTML出来
      filename: &apos;index.html&apos; // 默认值就是index.html, 便于开发人员自己查看
    })
],
</code></pre></li>
</ol>
<h3 id="loader的使用"><a href="#loader的使用" class="headerlink" title="loader的使用"></a>loader的使用</h3><ul>
<li><p>webpack默认情况下只支持js文件的打包编译, 除此以外所有的文件都无法解析处理</p>
</li>
<li><p>这样设计的目的是为了让webpack更轻量级, 可定制性更高, 根据开发者的需要而选择合适的loader来解析对应的文件</p>
</li>
<li><p>所以提出了loader的概念, 主要的目的是为了处理一些其他文件的打包编译</p>
</li>
</ul>
<p>在webpack中, 最基础的css文件也无法处理, 而且使用了webpack之后, css也不会像以前那样在HTML中引入, 而是放在<code>main.js</code>中使用es6的<code>import</code>语法引入:</p>
<pre><code>import &apos;./src/css/index.css&apos;
</code></pre><h4 id="css-loader和style-loader的使用"><a href="#css-loader和style-loader的使用" class="headerlink" title="css-loader和style-loader的使用"></a>css-loader和style-loader的使用</h4><p>由于项目中并未安装<code>css-loader</code> 所以无法解析css后缀的文件</p>
<ol>
<li><p>安装css-loader和style-loader</p>
<pre><code>npm i style-loader css-loader -D
</code></pre></li>
<li><p>配置loader</p>
<p> rules节点表示loader的匹配规则, 根据不同的正则来匹配不同的文件类型, 从而选择合适的loader来解析文件</p>
<pre><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]
      }
    ]
  }
}
</code></pre><p> <strong>注意: loader是有加载顺序的, 顺序是从右到左</strong></p>
<p> 为什么会有style-loader和css-loader呢?</p>
<p> css-loader用于解析css文件, 将其解析为样式, 交给style-loader应用到页面中</p>
</li>
</ol>
<h4 id="less-loader的使用"><a href="#less-loader的使用" class="headerlink" title="less-loader的使用"></a>less-loader的使用</h4><p>根据上面的经验来学习less-loader</p>
<ol>
<li><p>装包, 注意: 需要装less-loader和less两个包</p>
<pre><code>npm i less-loader less -D
</code></pre></li>
<li><p>配置</p>
<pre><code>module: {
    rules: [
      { test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] },
      // less-loader
      { test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] }
    ]
},
</code></pre></li>
</ol>
<h4 id="sass-loader的使用"><a href="#sass-loader的使用" class="headerlink" title="sass-loader的使用"></a>sass-loader的使用</h4><p>根据上面的经验来学习sass-loader</p>
<ol>
<li><p>装包, 注意需要安装sass-loader和node-sass两个包</p>
<pre><code>npm i sass-loader node-sass webpack -D
</code></pre></li>
<li><p>配置</p>
<pre><code>module: {
    rules: [
      { test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] },
      // less-loader
      { test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] },
      { test: /\.(scss|sass)$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] },
    ]
},
</code></pre></li>
</ol>
<h4 id="url-loader的使用"><a href="#url-loader的使用" class="headerlink" title="url-loader的使用"></a>url-loader的使用</h4><p>根据上面的经验来学习url-loader</p>
<p>作用: 由于webpack无法加载图片, 在css中如果使用了<code>background-image</code>, webpack就会报错, 同理如果使用了字体文件也无法加载</p>
<p>此时都需要使用<code>file-loader</code>或者<code>url-loader</code></p>
<p>两者的区别在于: <code>url-loader</code> 更高级一些, 可以添加一些配置, 实现在指定大小以内的图片进行base64的转码, 减少浏览器的二次请求</p>
<ol>
<li><p>装包</p>
<pre><code>npm i -D url-loader file-loader
</code></pre></li>
<li><p>配置</p>
<pre><code>{
    test: /\.(png|jpg|gif|jpeg|bmp|webp)$/,
    use: [&apos;url-loader?limit=8192&amp;name=[hash:8]-[name].[ext]&apos;]
    // use: [
    //   {
    //     loader: &apos;url-loader&apos;,
    //     options: {
    //       limit: 8192 // 限制 单位为byte  8192字节是8KB
    //     }
    //   }
    // ]
  },
  { test: /\.(eot|svg|ttf|woff|woff2)$/, use: [&apos;url-loader&apos;] }
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">WangXiang</p>
              <p class="site-description motion-element" itemprop="description">时间不负有心人</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WangXiang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
